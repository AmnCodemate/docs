var fs = require('fs');
var path = require('path');
var metalsmith = require('../scripts/metalsmith');
var Crawler = require('simplecrawler');
var cheerio = require('cheerio');
var url = require('url');
var util = require('util');
var chalk = require('chalk');
var _ = require('lodash');

// Ignore links to these hosts since they occasionally fail on Travis
// even though the links are valid. It's worth the risk of dead links to
// avoid flaky builds
var ignoreHosts = [
  'vimeo.com',
  'tools.usps.com',
  'www.microsoft.com',
  'www.mouser.com',
  'www.oracle.com',
  'datasheets.maximintegrated.com',
  // Broken webserver that returns 404 not found for regular pages
  'www.emaxmodel.com',
  'mingw.org', // seems to be a temporary server problem, will check back later
  '192.168.0.1',
];
var devices = ['photon', 'electron', 'core', 'raspberry-pi', 'argon', 'boron', 'xenon'];
var isPullRequest = process.env.TRAVIS_PULL_REQUEST && process.env.TRAVIS_PULL_REQUEST !== 'false';
var updateCache = process.env.UPDATE_CACHE && process.env.UPDATE_CACHE !== 'false';
if (updateCache) {
	// If updating cache (local build) also enable pull-request mode to avoid checking edit links
	isPullRequest = true;
}
var stats = {externalDownloads:0, pagesCrawled:0, skippedInCache:0, skippedLocal:0, urlsInDownloadsFile:0};

var start = new Date().getTime();
var crawlStart;

var downloads = {};
const downloadsPath = path.resolve(__dirname, '../config/downloads.json');

if (!updateCache) {
	try {
		var downloads = JSON.parse(fs.readFileSync(downloadsPath), 'utf8');
	
		var oldest = Math.floor(new Date().getTime() / 1000) - (3 * 24 * 60 * 60); 
		if (downloads.fetched < oldest) {
			// Downloads data is too old to reuse, discard the saved urls
			downloads.urls = [];
			delete downloads.fetched;
		}
	
		console.log(downloads.urls.length + ' urls read from ' + downloadsPath);
		stats.urlsInDownloadsFile = downloads.urls.length;
	}
	catch(e) {
		console.log('exception loading ', e)
	}
}
else {
	console.log('UPDATE_CACHE mode, generating new downloads list');
}
if (!downloads.urls) {
	downloads.urls = [];
}
var localDownloads = [];

function checkUrl(url) {
	if (url.indexOf('localhost') < 0) {
		// External download
		for(var ii = 0; ii < downloads.urls.length; ii++) {
			if (downloads.urls[ii] === url) {
				stats.skippedInCache++;
				return true;
			}
		}
		downloads.urls.push(url);
	}
	else {
		// Internal download
		for(var ii = 0; ii < localDownloads.length; ii++) {
			if (localDownloads[ii] === url) {
				stats.skippedLocal++;
				return true;
			}
		}
		localDownloads.push(url);		
	}
	return false;
}

function classifyUrl(item) {
  var info = {
    external: item.host !== 'localhost',
    image: item.path.match(/\.[png|jpg|jpeg|bmp|gif]/i),
    githubEditLink: item.url.indexOf('https://github.com/particle-iot/docs/tree') === 0,
    autogeneratedApiLink: item.host === 'localhost' && item.path.indexOf('/reference/device-cloud/api/') === 0,
    isFirmwareReference: item.path.indexOf('/reference/device-os/firmware') === 0
  };
  return info;
}

function shouldCrawl(qurl) {
  if (qurl.indexOf('#') === 0) {
    return false;
  }
  return true;
}

describe('Crawler', function() {
  before(function(done) {
    this.timeout(240000);
    console.log('Building...');
    var buildStart = new Date().getTime();
    
    server = metalsmith.test(function() {
    	stats.metalsmithBuildTime = (new Date().getTime() - buildStart) / 1000;
    	done();
    });
  });

  after(function(done) {
    this.timeout(60000);
    server.shutdown(function(err) {
      if (err) {
        return done(err);
      }
      console.log('Compressing...');
      metalsmith.compress(done);
    });
  });

  it('should complete without error', function(done) {
    this.timeout(500000);
    var errors = 0;
    var crawler = new Crawler('localhost', '/', 8081);
    crawler.maxConcurrency = 8;
    crawler.userAgent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.134 Safari/537.36';
    crawler.acceptCookies = false;
    crawler.timeout = 30000;
    crawler.filterByDomain = false;
    crawler.interval = 5;
    crawler.supportedMimeTypes = [/^text\//i];
    crawler.downloadUnsupported = false;

    crawlStart = new Date().getTime();
    
    crawler.addFetchCondition(function(parsedUrl) {
      return parsedUrl.protocol !== 'mailto';
    });
    crawler.addFetchCondition(function(parsedUrl) {
      return !(parsedUrl.host === 'localhost' && parsedUrl.port === 35729);
    });
    ignoreHosts.forEach(host => {
      crawler.addFetchCondition(function(parsedUrl) {
        return (parsedUrl.host !== host);
      });
    });

    crawler.addDownloadCondition(function(queueItem) {
      var uriis = classifyUrl(queueItem);
      if (uriis.githubEditLink) {
    	  return false;
      }
      if (uriis.external) {
    	  stats.externalDownloads++;
      }
      return !uriis.external;
    });

    crawler.discoverResources = function(buf, queueItem) {
      stats.pagesCrawled++;
      
      var urlis = classifyUrl(queueItem);
      if (urlis.external || urlis.image) {
        return [];
      }

      var $ = cheerio.load(buf.toString(), {
        normalizeWhitespace: false,
        xmlMode: false,
        decodeEntities: true
      });

      var parsedUrl = url.parse(queueItem.url);
      // is this the redirector page? follow device tree from here
      // this might make the crawl take ALOT longer
      if ($('#device-redirector').length === 1) {
        // determine if fromUrl was device specific
        var selectDevice;
        var parsedFromUrl = url.parse(queueItem.referrer);
        var devicePath = _.intersection(parsedFromUrl.pathname.split('/'), devices);
        if (devicePath.length > 0) {
          selectDevice = devicePath[0];
        }

        $('ul.devices').find('a').each(function(index, a) {
          // if we come from a device-specific page, only choose that device link forward
          if (selectDevice && $(a).attr('id') !== (selectDevice + '-link')) {
            return;
          }

          var toQueueUrl = $(a).attr('href');

          // include hash used to access redirector
          var absolutePath = url.resolve(queueItem.url, toQueueUrl) + (parsedUrl.hash || '');
          // preserve original fromUrl and content
          // c.queue([{
          //   uri: absolutePath,
          //   callback: crawlCallback.bind(null, fromUrl, absolutePath, content)
          // }]);
          if (!queueItem.meta) {
            console.log(queueItem);
          }
          if (checkUrl(absolutePath)) {
        	  return [];
          }
          
          crawler.queueURL(absolutePath, queueItem, { content: queueItem.meta.content });
        });
        return [];
      }

      // make sure the hash used is valid on this page
      if (parsedUrl.hash) {
        if (isPullRequest && urlis.autogeneratedApiLink) {
          return [];
        }

        if ($(parsedUrl.hash).length === 0) {
          console.error(chalk.red(util.format('ERROR: 404 (missing hash) ON %s CONTENT %s LINKS TO %s', queueItem.referrer, queueItem.meta.content, queueItem.url)));
          errors++;
        }
        // only check the hash here
        // let the non-hash version crawl the rest of the tree
        return [];
      }

      $('a').each(function(index, a) {
        var toQueueUrl = $(a).attr('href');
        var linkContent = $(a).text();
        if (!toQueueUrl) return;

        if (toQueueUrl.indexOf('#') === 0 && toQueueUrl.length > 1) {
          if (isPullRequest && urlis.autogeneratedApiLink) {
            return;
          }

          if ($(toQueueUrl).length === 0) {
            console.error(chalk.red(util.format('ERROR: 404 relative link ON %s CONTENT %s LINKS TO %s', queueItem.url, linkContent, toQueueUrl)));
            errors++;
          }
        }

        if (!shouldCrawl(toQueueUrl)) {
          return;
        }
        var absolutePath = url.resolve(queueItem.url, toQueueUrl);
        // Remove hash
        absolutePath = absolutePath.replace(/#.*/, '');
        
        if (checkUrl(absolutePath)) {
      	  return;
        }

        crawler.queueURL(absolutePath, queueItem, { content: linkContent });
      });

      $('img').each(function (index, img) {
        var toQueueUrl = $(img).attr('src');
        if (!toQueueUrl) return;

        toQueueUrl = url.resolve(queueItem.url, toQueueUrl);
        
        if (checkUrl(toQueueUrl)) {
      	  return;
        }

        crawler.queueURL(toQueueUrl, queueItem, { content: 'image' });
      });

      return [];
    };

    // crawler.on('fetchstart', function(queueItem) {
    //   console.log('start', queueItem.url);
    // });

    // crawler.on('fetchheaders', function(queueItem, response) {
    //   console.log('headers', queueItem.url, complete, len);
    // });

    // crawler.on('fetchcomplete', function(queueItem) {
    //   console.log('complete', queueItem.url);
    // });

    crawler.on('fetchtimeout', function (queueItem) {
      var msg = util.format('timeout ON %s CONTENT %s LINKS TO %s', queueItem.referrer, queueItem.meta.content, queueItem.url);
      var urlis = classifyUrl(queueItem);
      if (urlis.external || urlis.isFirmwareReference) {
    	  // Warn only for timeouts on external URLs and the firmware reference (because it's very large)
        console.log(chalk.yellow('WARN: ' + msg));
      } else {
        console.error(chalk.red('ERROR: ' + msg));
        errors++;
      }
    });

    function fetchResultError(queueItem, response) {
      if (queueItem.stateData.code === 429) {
        return;
      }
      if (queueItem.stateData.code === 200) {
        return;
      }

      var urlis = classifyUrl(queueItem);
      if ((isPullRequest && urlis.githubEditLink && queueItem.stateData.code === 404) ||
          (isPullRequest && urlis.autogeneratedApiLink && queueItem.stateData.code === 404)) {
        return;
      }
      
      // TEMPORARY: I can't get a clean build without fixing this redirect, but I can't fix the redirect without a clean build!
      // ERROR: 404 ON https://www.particle.io/particle-pi CONTENT landing page LINKS TO https://docs.particle.io/guide/getting-started/start/raspberry-pi/
      if (queueItem.referrer === 'https://www.particle.io/particle-pi') {
    	  return;
      }

      var msg = util.format('%s ON %s CONTENT %s LINKS TO %s', queueItem.stateData.code, queueItem.referrer, queueItem.meta.content, queueItem.url);
      if (urlis.external && Math.floor(queueItem.stateData.code / 100) === 5) {
        // allow 5XX status codes on external links
        console.log(chalk.yellow('WARN: ' + msg));
        return;
      }
      console.error(chalk.red('ERROR: ' + msg));
      errors++;
    }

    crawler.on('fetch404', fetchResultError);
    crawler.on('fetcherror', fetchResultError);
    crawler.on('complete', function() {

      stats.crawlTime = (new Date().getTime() - crawlStart) / 1000; 
      stats.totalTime = (new Date().getTime() - start) / 1000; 
      
      console.log('stats: ', stats);
    	    	
      if (errors > 0) {
        return done(new Error('There are ' + errors + ' broken link(s)'));
      }
      else {
    	  // If we newly generated the file, save it out, otherwise leave the file as it was
    	  if (!downloads.fetched) {
	     	  downloads.fetched = Math.floor(new Date().getTime() / 1000);
	
	    	  // Success, write out the changed downloads file
	     	  fs.writeFileSync(downloadsPath, JSON.stringify(downloads, null, 2));
    	  }
      }
      return done();
    });
    crawler.start();
  });

});

